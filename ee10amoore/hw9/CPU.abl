MODULE      CPU
TITLE      'Caltech10 CPU'


" Description:  This is file for implementing the Caltech10 CPU.
"               It is the top-level module which will instantiate and connect
"               all other modules. It combines the ProgramAccess, DataAccess, ALU,
"               and Control Units together.

"               The Control Unit takes in the Program Data Bus and Flags, sets the RD WR IO signals, 
"               and, sets the necessary control signals for the ALU/DAU/PAU.
"               The PAU takes in an Address and Offset data, outputs the Program Address Bus
"               The DAU takes in the Offset data and outputs the Data Address Bus
"               The ALU takes in the MUX'd data and returns the accumulator and flag outputs, which
"               are MUX'd 2:1 (4:1 with CALL/RTS) into the Data Data Bus

" Inputs:         ProgramDB[15..0]  - the 16-bit program data bus
"                 Reset             - system reset signal
"                 Clock             - system clock
"
" I/O:            DataDB[7..0]      - the 8-bit data data bus
"
" Outputs:        ProgramAB[12..0]  - the 13-bit program address bus
"                 DataAB[7..0]      - the 8-bit data address bus
"                 RD                - read signal for the data data bus
"                 WR                - write signal for the data data bus
"                 IO                - memory (0) or I/O (1) is being accessed
"
" Status Outputs: Accum[7..0]       - the 8-bit accumulator
"                 Flags[7..0]       - the 8-bit flag register
"                 XReg[7..0]        - the 8-bit X register
"                 SReg[7..0]        - the 8-bit S register


" Revision History:
" 02/15/18   Glen George  Initial Revision
" 01/05/21   Glen George  Updated comments
" 03/16/23   Steven Lei   Implemented modules
" 03/16/23   Steven Lei   Updated Comments


" Pin/Signal Declarations

" Inputs

ProgramDB15..ProgramDB0			pin;	"input  16-bit instruction data bus
Reset           				pin;	"input  system reset signal
Clock           				pin;	"input  system clock


" I/O

DataDB7..DataDB0				pin;	"I/O  8-bit Data data bus


" Outputs

ProgramAB12..ProgramAB0			  pin;	"output  the 13-bit Program address bus
DataAB7..DataAB0				      pin;	"output  the 8-bit Data address bus
RD		                        pin;	"output  read signal for the Data data bus
WR						                pin;	"output  write signal for the Data data bus
IO						                pin;	"output  accessing memory (0) or I/O (1)


" Debugging/Status Outputs

Accum7..Accum0				pin;	 "the 8-bit accumulator
Flags7..Flags0				pin;	 "the flags (8 bits)
XReg7..XReg0				pin;	 "the 8-bit X register
SReg7..SReg0				pin;	 "the 8-bit S register

" Internal signals

" declare the used modules

ProgramAccess INTERFACE  (Offset7..Offset0, Direct12..Direct0,
                          Load, Select2..Select0,
                          Reset, Clock
                          -> ProgAddr12..ProgAddr0, PC12..PC0);

DataAccess INTERFACE    (Accum7..Accum0, Offset7..Offset0,
                         UseX, ResetOff,
			       IDOn, Post, Inc, 
                         Reset, Clock
                       -> DataAddr7..DataAddr0, XReg7..XReg0, SReg7..SReg0);
                       
ALU INTERFACE           (Data7..Data0,
                         Mode3..Mode0,
                         LoadFlags,
                         WC,
                         F3..F0,
                         MaskC, MaskV, MaskS, MaskZ,
                         Reset, Clock
                       -> Accum7..Accum0, Flags7..Flags0);

ControlUnit INTERFACE   (PDB15..PDB0, Flags7..Flags0, Reset, Clock
                       -> IR15..IR0,
                          ALU_M3..ALU_M0, ALU_LF, ALU_WC, ALU_F3..ALU_F0, 
                          PA_Load, PA_Select2..PA_Select0,
                          PushF, PopF,                 
                          DA_UseX, DA_ResetOff, DA_IDOn, DA_Post, DA_Inc,
                          Imm,
                          RD, WR, IO
                         );


" create instances of the modules

PAUnit    FUNCTIONAL_BLOCK  ProgramAccess;
DAUnit    FUNCTIONAL_BLOCK  DataAccess;
ALUnit    FUNCTIONAL_BLOCK  ALU;
CUnit     FUNCTIONAL_BLOCK  ControlUnit;

" Busses

ProgramAB  =  [ProgramAB12..ProgramAB0];			     "13-bit Program address bus
ProgramDB  =  [ProgramDB15..ProgramDB0];			     "16-bit Program data bus
DataAB     =  [DataAB7..DataAB0];					"8-bit Data address bus
DataDB     =  [DataDB7..DataDB0];					"8-bit Data data bus
XReg       =  [XReg7..XReg0];
SReg       =  [SReg7..SReg0];

" ------------------------
EQUATIONS
" ------------------------
" output enables

      " Set PDB of control unit
CUnit.[PDB15..PDB0] = ProgramDB;
      
      " RD WR IO signals
      " Data data bus is enabled when writing

DataDB.OE  = WR;
IO = CUnit.IO; 
RD = CUnit.RD;
WR = CUnit.WR;

"###########################
"#######CONTROL SIGNALS#####
"###########################

PAUnit.[Load, Select2..Select0] = [CUnit.PA_Load, CUnit.PA_Select2..CUnit.PA_Select0];

ALUnit.[Mode3..Mode0, LoadFlags, WC, F3..F0] = CUnit.[ALU_M3..ALU_M0, ALU_LF, ALU_WC, ALU_F3..ALU_F0];
ALUnit.[MaskC,MaskV,MaskS,MaskZ] = [0,0,0,0];

DAUnit.[UseX, ResetOff, IDOn, Post, Inc] = CUnit.[DA_UseX, DA_ResetOff, DA_IDOn, DA_Post, DA_Inc];

"###########################
"#######FLAGS###############
"###########################

      " We need to set the Flags, which come from the ALU. Note that the Flags
      " of the ALU will be set if doing PopF

[Flags7..Flags0]        =  ALUnit.[Flags7..Flags0];
CUnit.[Flags7..Flags0]  =  ALUnit.[Flags7..Flags0];

"###########################
"#######BUSES###############
"###########################

"ALU INPUT
      " We either input addressed or the immediate data, so we mux 2:1
      " immediate data is the last 8 bits of IR

ALUnit.[Data7..Data0] = (!CUnit.Imm & DataDB)
                      # ( CUnit.Imm & [CUnit.IR7..CUnit.IR0]); 
"ALU OUTPUT
      " Data-Databus is dependent on Accumulator, Flags, or PC (CALL)
      " 4:1 MUX the Data/DataBus for ST which is WR, PUSHF, CALL
      " Else don't change the DataDB

DataDB = (WR & !CUnit.PushF & ALUnit.[Accum7..Accum0])       "ST
       # (WR &  CUnit.PushF & ALUnit.[Flags7..Flags0])       "pushF
      "#CALL & PC
      "#CAll & PC

"DAU INPUT
      "Always use the offset given by the instruction bits

DAUnit.[Accum7..Accum0]   = [.X.,.X.,.X.,.X.,.X.,.X.,.X.,.X.]; " don't worry, ec
DAUnit.[Offset7..Offset0] = [CUnit.IR7..CUnit.IR0];

"DAU OUTPUT
      "sets the DataAddr, XReg, SReg,
      "if we are immediate addressing, the DAB should not change.

DataAB = DAUnit.[DataAddr7..DataAddr0]; 
XReg =   DAUnit.[XReg7..XReg0];
SReg =   DAUnit.[SReg7..SReg0];

"PAU INPUT
      " takes in 13 bits of direct address data, which is just last 13 bits of instructions
      " Offset Data is dependent on RTS (HW10)

PAUnit.[Direct12..Direct0] = [CUnit.IR12..CUnit.IR0]; 
    
        " 2:1 mux on offset if RTS

PAUnit.[Offset7..Offset0] = ([CUnit.IR7..CUnit.IR0]);
                          " # (DataDB) RTS
"PAU OUTPUT
      " just Program Address Bus. PC used for call

ProgramAB = PAUnit.[ProgAddr12..ProgAddr0];

      
" Clock and Reset all units

CUnit.Reset = !Reset;
CUnit.Clock = Clock;

PAUnit.Reset = !Reset;
PAUnit.Clock = Clock;

ALUnit.Reset = !Reset;
ALUnit.Clock = Clock;

DAUnit.Reset = !Reset;
DAUnit.Clock = Clock;

" most signals are always enabled
ProgramAB.OE         =  ^h1FFF;
DataAB.OE            =  ^hFF;
RD.OE                =  1;
WR.OE                =  1;
IO.OE                =  1;
[Accum7..Accum0].OE  =  ^hFF;
[Flags7..Flags0].OE  =  ^hFF;
[XReg7..XReg0].OE    =  ^hFF;
[SReg7..SReg0].OE    =  ^hFF;



END  CPU